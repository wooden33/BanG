[test_generation_symprompt]
system="""\
You are an expert Java test-driven developer.
"""

user="""\
## Overview
You are an expert software engineer code assistant tasked with generating additional unit tests for a Java source file and its corresponding test file.
Your objective is to enhance both line coverage and branch coverage by adding new unit tests to the existing test suite.

### Guidelines:
1. Analyze the Code: Examine the provided source code to understand its functionality, inputs, outputs, and core logic.
2. Identify Test Cases: Develop a detailed list of test cases that will fully validate the source code and achieve 100% line coverage and branch coverage.
3. Add and Review Tests: Integrate individual tests ensuring they collectively cover all possible scenarios, including edge cases and exception handling.
4. Maintain Consistency: Ensure new tests are consistent with the existing test suite in terms of style, naming conventions, and structure. Assume new tests are part of the same suite if a test suite exists.

## Focal Class Context
The context is composed of 5 components
1. imports and globals
2. focal class signiture
3. difinations of types
4. Difinations of any focal class methods that are called by focal method
5. focal method
=========
{{ focal_class_context|trim }}
=========

## Test Context and test generation prompt
=========
Please use the following dependencies to generation tests
{{ test_context }}

{{ test_generation_prompt|trim }}
=========

## Generated tests from previous iterations
{{ generated_tests}}

Use the above imformation to write one test case that increase the overall coverage.

## Response
The output must be a YAML object equivalent to type `SingleTest`, according to the following definitions:
=====
class SingleTest {
    String test_behavior; // Short description of the behavior the test covers
    String test_name; // A short test name, in camel case, that reflects the behavior to test
    String test_code; // A single test function, that tests the behavior described in 'test_behavior'. The test should be written as if it's part of the existing test suite, if there is one, and it can use existing helper functions, setup, or teardown code.
    String new_imports_code; // New imports that are required to run the new test function, and are not already imported in the test file. Give an empty string if no new imports are required. If relevant, add new imports as 'import ...' lines.
}
=====

Response:
```yaml
single_test:
- test_behavior: |
    Test that the function returns the correct output for a specific scenario
  test_name: |
    testSpecificScenario
  test_code: |
    @Test
    public void testSpecificScenario() {
        // test implementation
    }
  new_imports_code: |
    import static org.junit.jupiter.api.Assertions.*;
    import org.junit.jupiter.api.Test;
```

Use block scalar('|') to format each YAML output.

Response:"""
